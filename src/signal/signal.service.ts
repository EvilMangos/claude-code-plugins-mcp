import { inject, injectable } from "inversify";
import { TOKENS } from "../container";
import type { IMetadataRepository } from "../metadata/types/metadata.repository.interface";
import { formatRepositoryError } from "../utils/format-repository.error";
import { formatZodError } from "../utils/format-zod.error";
import {
	type SaveSignalInput,
	saveSignalSchema,
} from "./schemas/save-signal.schema";
import {
	type WaitSignalInput,
	waitSignalSchema,
} from "./schemas/wait-signal.schema";
import type { ISaveSignalResult } from "./types/save-signal-result.interface";
import type { ISignalRepository } from "./types/signal.repository.interface";
import type { ISignalService } from "./types/signal.service.interface";
import type { IWaitSignalResult } from "./types/wait-signal-result.interface";
import { ReportType } from "../types/report.type";
import { SignalContent } from "./schemas/signal-content.schema";
import { SignalStatus } from "./types/signal-status.type";

/**
 * Service for managing workflow signals.
 * Provides methods to save signals to repository.
 */
@injectable()
export class SignalService implements ISignalService {
	constructor(
		@inject(TOKENS.SignalRepository)
		private readonly repository: ISignalRepository,
		@inject(TOKENS.MetadataRepository)
		private readonly metadataRepository: IMetadataRepository
	) {}

	/**
	 * Save a workflow signal to in-memory repository.
	 * Does NOT update metadata step - step progression is handled by waitSignal
	 * to properly support parallel steps (increment once after ALL signals received).
	 *
	 * @param input - The signal input containing taskId, signalType, and content
	 * @returns A result object with success status and optional error message
	 */
	async saveSignal(input: SaveSignalInput): Promise<ISaveSignalResult> {
		// Validate input
		const parseResult = saveSignalSchema.safeParse(input);

		if (!parseResult.success) {
			return {
				success: false,
				error: formatZodError(parseResult.error),
			};
		}

		const validatedInput = parseResult.data;

		try {
			// Save to repository (timestamp is generated by repository)
			this.repository.save(
				validatedInput.taskId,
				validatedInput.signalType,
				validatedInput.content
			);

			return { success: true };
		} catch (error) {
			return {
				success: false,
				error: formatRepositoryError(error),
			};
		}
	}

	/**
	 * Wait for one or more workflow signals to appear in repository.
	 * Polls the repository at regular intervals until **all** requested signals are found or the timeout is reached.
	 * When multiple signal types are provided, it returns combined content in the same order as requested.
	 *
	 * @param input - The signal input containing taskId, signalType (single or array), and optional timeout/polling settings
	 * @returns A result object with success status, combined signal content if all are found, wait time, or error message
	 */

	async waitSignal(input: WaitSignalInput): Promise<IWaitSignalResult> {
		// Validate input
		const parseResult = waitSignalSchema.safeParse(input);

		if (!parseResult.success) {
			return {
				success: false,
				error: formatZodError(parseResult.error),
			};
		}

		const validatedInput = parseResult.data;
		const { taskId, signalType, timeoutMs, pollIntervalMs } = validatedInput;

		// Normalize + de-duplicate (preserve order)
		const signalTypes: ReportType[] = Array.from(
			new Set(Array.isArray(signalType) ? signalType : [signalType])
		);

		const startTime = Date.now();

		try {
			// Keep track of signals we already have
			const found = new Map<ReportType, { content: SignalContent }>();

			// Poll until ALL signals are found or timeout
			while (Date.now() - startTime < timeoutMs) {
				for (const type of signalTypes) {
					if (found.has(type)) continue;

					const signal = this.repository.get(taskId, type);

					if (signal) {
						found.set(type, { content: signal.content });
					}
				}

				if (found.size === signalTypes.length) {
					const content: SignalContent[] = signalTypes
						.map((signalType) => found.get(signalType)?.content)
						.filter((value) => !!value);

					// Update metadata step based on aggregated signal statuses
					// This handles parallel steps correctly: increment/decrement once after ALL signals received
					const allPassed = content.every(
						(c) => c.status === SignalStatus.PASSED
					);
					if (allPassed) {
						this.metadataRepository.incrementStep(taskId);
					} else {
						// At least one signal failed - go back to retry
						this.metadataRepository.decrementStep(taskId);
					}

					return {
						success: true,
						content,
						waitedMs: Date.now() - startTime,
					};
				}

				await this.sleep(pollIntervalMs);
			}

			// Timeout reached
			const missing = signalTypes.filter((t) => !found.has(t));
			return {
				success: false,
				error: `Timeout after ${timeoutMs}ms waiting for signals [${missing.join(
					", "
				)}] (taskId: ${taskId})`,
				waitedMs: Date.now() - startTime,
			};
		} catch (error) {
			return {
				success: false,
				error: formatRepositoryError(error),
				waitedMs: Date.now() - startTime,
			};
		}
	}

	/**
	 * Sleep for a specified duration.
	 * @param ms - Duration in milliseconds
	 */
	private sleep(ms: number): Promise<void> {
		return new Promise((resolve) => setTimeout(resolve, ms));
	}
}

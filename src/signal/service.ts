import { inject, injectable } from "inversify";
import { TOKENS } from "../container";
import type { IMetadataRepository } from "../metadata/types/metadata-repository.interface";
import { formatStorageError } from "../utils/format-storage.error";
import { formatZodError } from "../utils/format-zod.error";
import {
	type SaveSignalInput,
	saveSignalSchema,
} from "./schemas/save-signal.schema";
import {
	type WaitSignalInput,
	waitSignalSchema,
} from "./schemas/wait-signal.schema";
import type { ISaveSignalResult } from "./types/save-signal-result.interface";
import type { ISignalRepository } from "./types/signal-repository.interface";
import type { ISignalService } from "./types/signal-service.interface";
import type { IWaitSignalResult } from "./types/wait-signal-result.interface";

/**
 * Service for managing workflow signals.
 * Provides methods to save signals to storage.
 */
@injectable()
export class SignalServiceImpl implements ISignalService {
	constructor(
		@inject(TOKENS.SignalRepository)
		private readonly repository: ISignalRepository,
		@inject(TOKENS.MetadataRepository)
		private readonly metadataRepository: IMetadataRepository
	) {}

	/**
	 * Save a workflow signal to in-memory storage.
	 * @param input - The signal input containing taskId, signalType, and content
	 * @returns A result object with success status and optional error message
	 */
	async saveSignal(input: SaveSignalInput): Promise<ISaveSignalResult> {
		// Validate input
		const parseResult = saveSignalSchema.safeParse(input);

		if (!parseResult.success) {
			return {
				success: false,
				error: formatZodError(parseResult.error),
			};
		}

		const validatedInput = parseResult.data;

		try {
			// Save to repository (timestamp is generated by repository)
			this.repository.save(
				validatedInput.taskId,
				validatedInput.signalType,
				validatedInput.content
			);

			// Update metadata step based on signal status
			if (validatedInput.content.status === "passed") {
				this.metadataRepository.incrementStep(validatedInput.taskId);
			} else {
				this.metadataRepository.decrementStep(validatedInput.taskId);
			}

			return { success: true };
		} catch (error) {
			return {
				success: false,
				error: formatStorageError(error),
			};
		}
	}

	/**
	 * Wait for a workflow signal to appear in storage.
	 * Polls the storage at regular intervals until the signal is found or timeout is reached.
	 * @param input - The signal input containing taskId, signalType, and optional timeout/polling settings
	 * @returns A result object with success status, signal content if found, wait time, or error message
	 */
	async waitSignal(input: WaitSignalInput): Promise<IWaitSignalResult> {
		// Validate input
		const parseResult = waitSignalSchema.safeParse(input);

		if (!parseResult.success) {
			return {
				success: false,
				error: formatZodError(parseResult.error),
			};
		}

		const validatedInput = parseResult.data;
		const { taskId, signalType, timeoutMs, pollIntervalMs } = validatedInput;

		const startTime = Date.now();

		try {
			// Poll until signal is found or timeout
			while (Date.now() - startTime < timeoutMs) {
				const signal = this.repository.get(taskId, signalType);

				if (signal) {
					return {
						success: true,
						content: signal.content,
						waitedMs: Date.now() - startTime,
					};
				}

				// Wait before next poll
				await this.sleep(pollIntervalMs);
			}

			// Timeout reached
			return {
				success: false,
				error: `Timeout after ${timeoutMs}ms waiting for signal '${signalType}' (taskId: ${taskId})`,
				waitedMs: Date.now() - startTime,
			};
		} catch (error) {
			return {
				success: false,
				error: formatStorageError(error),
				waitedMs: Date.now() - startTime,
			};
		}
	}

	/**
	 * Sleep for a specified duration.
	 * @param ms - Duration in milliseconds
	 */
	private sleep(ms: number): Promise<void> {
		return new Promise((resolve) => setTimeout(resolve, ms));
	}
}
